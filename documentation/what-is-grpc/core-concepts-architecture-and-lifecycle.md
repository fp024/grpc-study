# 핵심 개념, 아키텍처 및 수명 주기 (lifecycle)

#### gRPC 아키텍처 및 RPC 수명 주기에 대한 개요와 함께 주요 gRPC 개념을 소개합니다.

### 내용

* 개요
  * 서비스 정의
  * API 사용하기
  * 동기 vs 비동기
* RPC 수명 주기
  * Unary RPC
  * 서버 스트리밍 RPC
  * 클라이언트 스트리밍 RPC
  * 양방향 스트리밍 RPC
  * 데드라인 / 타임아웃
  * RPC 종료
  * RPC 취소
  * 메타 데이터
  * 채널

gRPC에 대해 잘 모르시나요? 먼저 [gRPC의 소개](introduction-to-grpc.md)를 읽어보세요. 언어별 세부 정보는 선택한 언어의 빠른 시작, 튜토리얼과 레퍼런스 문서를 참조해보세요.



## 개요

### 서비스 정의 (Service definition)

많은 RPC 시스템과 마찬가지로 gRPC는 파라미터 및 반환 타입을 사용하여 원격으로 호출할 수 있는 메서드를 지정하여 서비스를 정의한다는 아이디어를 기반으로 합니다. 기본적으로 gRPC는 서비스 인터페이스와 페이로드 메시지 구조 모두를 설명하기 위해 프로토콜 버퍼를 IDL(인터페이스 정의 언어)로 사용합니다. 원하는 경우 다른 대안을 사용할 수 있습니다.

```protobuf
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
```

gRPC를 사용하면 4가지 종류의 서비스 메서드를 정의할 수 있습니다.

* Unary RPC

  클라이언트가 단일 요청을 서버에 보내고 일반 함수 호출과 마찬가지로 단일 응답을 받는 Unary RPC.
  ```protobuf
  rpc SayHello(HelloRequest) returns (HelloResponse);
  ```

* 서버 스트리밍 RPC

  클라이언트가 서버에 요청을 보내고 (서버의) 스트림을 가져와서 일련의 메시지(messages of sequence)를 다시 읽는 서버 스트리밍 RPC. 클라이언트는 반환된 스트림에서 더 이상 메시지가 없을 때까지  읽습니다. gRPC는 개별 RPC 호출 내에서 메시지 순서를 보장합니다.

  ```protobuf
  rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
  ```

* 클라이언트 스트리밍 RPC

  클라이언트가 일련의 메시지(messages of sequence)를 작성하여 서버로 보내고 제공된 스트림을 다시 사용하는 클라이언트 스트리밍 RPC. 클라이언트는 메시지 작성을 마치면 서버가 메시지를 읽고 응답을 반환할 때까지 기다립니다. 클라이언트는 메시지 작성을 마치면 서버가 메시지를 읽고 응답을 반환할 때까지 기다립니다. 다시 말해 gRPC는 개별 RPC 호출 내에서 메시지 순서를 보장합니다.

  ```protobuf
  rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
  ```

* 양방향 스트리밍 RPC

  양방향 스트리밍 RPC는 양쪽(서버측, 클라이언트측)에서 읽기-쓰기 스트림을 사용하여 일련의 메시지를 전송합니다. 두 스트림은 독립적으로 작동하므로 클라이언트와 서버는 원하는 순서대로 읽고 쓸 수 있습니다: 예를 들어, 서버는 응답을 쓰기 전에 모든 클라이언트 메시지를 수신하기 위해 기다릴 수도 있고, 메시지를 읽고 쓸 수도 있고, 읽기 및 쓰기의 다른 조합이 있을 수도 있습니다. 각 스트림의 메시지 순서는 유지됩니다.

  ```protobuf
  rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
  ```

아래의 RPC 수명 주기 섹션에서 다양한 유형의 RPC에 대해 자세히 알아볼 것입니다. 

### API 사용

`.proto` 파일의 서비스 정의에서 시작하여 gRPC는 클라이언트 측 및 서버 측 코드를 생성하는 프로토콜 버퍼 컴파일러 플러그인을 제공합니다. gRPC 사용자는 일반적으로 클라이언트 측에서 이러한 API를 호출하고 서버 측에서 해당 API를 구현합니다.

* 서버 측에서 서버는 서비스에서 선언한 메서드를 구현하고 gRPC 서버를 실행하여 클라이언트 호출을 처리합니다. gRPC 인프라는 들어오는 요청을 디코딩하고 서비스 메서드를 실행하며 서비스 응답을 인코딩합니다.

* 클라이언트 측에서 클라이언트에는 서비스와 동일한 메서드를 구현하는 스텁(일부 언어의 경우 선호되는 용어는 클라이언트)이라는 로컬 객체가 있습니다. 그런 다음 클라이언트는 로컬 객체에서 해당 메서드를 호출하여 적절한 프로토콜 버퍼 메시지 유형으로 호출에 대한 파라미터를 래핑할 수 있습니다 - gRPC는 서버에 요청을 보내고 서버의 프로토콜 버퍼 응답을 반환한 후 확인합니다.

  

### 동기(synchronous) vs 비동기(asynchronous)

서버에서 응답이 도착할 때까지 차단하는 동기 RPC 호출은 RPC가 원하는 프로시저 호출의 추상화에 가장 가깝습니다. 반면에 네트워크는 본질적으로 비동기적이며 많은 시나리오에서 현재 스레드를 차단하지 않고 RPC를 시작할 수 있는 것이 유용합니다.

대부분의 언어에서 gRPC 프로그래밍 API는 동기식 및 비동기식으로 제공됩니다. 각 언어의 자습서 및 참조 문서에서 자세한 내용을 확인할 수 있습니다(완전한 참조 문서는 곧 제공될 예정입니다).





## RPC 수명 주기

이 섹션에서는 gRPC 클라이언트가 gRPC 서버 메서드를 호출할 때 어떤 일이 발생하는지 자세히 살펴보겠습니다. 전체 구현 세부 정보는 언어별 페이지를 참조하세요.

### Unary RPC

먼저 클라이언트가 단일 요청을 보내고 단일 응답을 받는 가장 단순한 유형의 RPC를 고려하세요.

1. 클라이언트가 스텁 메서드를 호출하면 이 호출에 대한 클라이언트의 **메타 데이터**, 메서드 이름, 해당하는 경우 지정된 **기한**(Deadline)을 사용하여 RPC가 호출되었음을 서버에 알립니다.
2. 그런 다음 서버는 자체적인 초기 메타데이터(응답 전에 전송되어야 함)를 즉시 다시 보내거나 클라이언트의 요청 메시지를 기다릴 수 있습니다. 먼저 발생하는 것은 애플리케이션별로 다릅니다.
3. 서버가 클라이언트의 요청 메시지를 받으면 응답을 생성하고 채우는 데 필요한 모든 작업을 수행합니다. 그런 다음 응답이 상태 세부정보(상태 코드 및 선택적 상태 메시지) 및 선택적 추적 메타데이터와 함께 클라이언트에 반환됩니다(성공한 경우).
4. 응답 상태가 OK이면 클라이언트는 응답을 받아 클라이언트 측에서 호출을 완료합니다.



### 서버 스트리밍 RPC

서버 스트리밍 RPC는 서버가 클라이언트의 요청에 대한 응답으로 메시지 스트림을 반환한다는 점을 제외하면 Unary RPC와 유사합니다. 모든 메시지를 보낸 후 서버의 상태 세부 정보(상태 코드 및 선택적 상태 메시지)와 선택적 추적 메타데이터가 클라이언트로 전송됩니다. 이렇게 하면 서버 측에서 처리가 완료됩니다. 클라이언트는 서버의 모든 메시지를 받으면 완료됩니다.



### 클라이언트 스트리밍 RPC

클라이언트 스트리밍 RPC는 클라이언트가 단일 메시지 대신 메시지 스트림을 서버로 보낸다는 점을 제외하고는 단일 RPC와 유사합니다. 서버는 일반적으로 단일 메시지(상태 세부 정보 및 선택적 추적 메타데이터와 함께)로 응답하지만 반드시 클라이언트의 모든 메시지를 수신한 후에 응답할 필요는 없습니다.



### 양방향 스트리밍 RPC

양방향 스트리밍 RPC에서 호출은 메서드를 호출하는 클라이언트와 클라이언트 메타데이터, 메서드 이름 및 기한(deadline)을 수신하는 서버에 의해 시작됩니다. 서버는 초기 메타데이터를 다시 보내거나 클라이언트가 메시지 스트리밍을 시작할 때까지 기다릴 수 있습니다.

클라이언트 측 및 서버 측 스트림 처리는 애플리케이션에 따라 다릅니다. 두 스트림은 독립적이므로 클라이언트와 서버는 어떤 순서로든 메시지를 읽고 쓸 수 있습니다. 예를 들어 서버는 메시지를 쓰기 전에 클라이언트의 모든 메시지를 수신할 때까지 기다리거나 서버와 클라이언트가 "핑퐁"(주고 받기) 할 수 있습니다. 서버는 요청을 받은 후 응답을 다시 보내고 클라이언트는 응답에 따라 다른 요청을 보냅니다.



### 데드라인 / 타임아웃

gRPC를 사용하면 클라이언트가 RPC가 `DEADLINE_EXCEEDED` 오류와 함께 종료되기 전에 RPC가 완료될 때까지 대기할 시간을 지정할 수 있습니다. 서버 측에서 서버는 특정 RPC가 시간 초과되었는지 또는 RPC를 완료하는 데 남은 시간을 확인하기 위해 쿼리할 수 있습니다.

기한 또는 시간 초과 지정은 언어에 따라 다릅니다: 일부 언어 API는 타임아웃(시간 초과, 시간 지속) 측면에서 작동하고 일부 언어 API는 데드라인(마감일, 고정 시점) 측면에서 작동하며 기본 데드라인이 있을 수도 있고 없을 수도 있습니다.



### RPC 종료

gRPC에서 클라이언트와 서버 모두 호출 성공에 대해 독립적이고 로컬(지역적인)에서 결정을 내리며 결론이 일치하지 않을 수 있습니다. 이것에 대해 예로 서버 측에서는 성공적으로 완료되는 RPC를 가질 수 있지만("나는 모든 응답을 보냈습니다!") 클라이언트 측에서는 실패할 수 있습니다("응답이 데드라인 이후에 도착했습니다!"). 클라이언트가 모든 요청을 보내기 전에 서버가 완료를 결정할 수도 있습니다.



### RPC 취소

클라이언트나 서버는 언제든지 RPC를 취소할 수 있습니다. 취소하면 더 이상 작업이 수행되지 않도록 RPC가 즉시 종료됩니다.

> #### 경고
>
> 취소하기 전에 변경한 사항은 롤백되지 않습니다.



### 메타 데이터

메타데이터는 키-값 쌍 목록 형식의 특정 RPC 호출(예: [인증 세부정보](https://grpc.io/docs/guides/auth/))에 대한 정보입니다. 여기서 키는 문자열이고 값은 일반적으로 문자열이지만 이진 데이터일 수도 있습니다. 메타데이터는 gRPC 자체에 대해 불투명합니다 - 이를 통해 클라이언트는 서버에 대한 호출과 관련된 정보를 제공할 수 있으며 그 반대의 경우도 마찬가지입니다.

메타데이터에 대한 액세스는 언어에 따라 다릅니다.



### 채널

gRPC 채널은 지정된 호스트 및 포트의 gRPC 서버에 대한 연결을 제공하며, 클라이언트 스텁을 생성할 때 사용됩니다. 클라이언트는 채널 인수를 지정하여 메시지 압축 켜기 또는 끄기와 같은 gRPC의 기본 동작을 수정할 수 있습니다. 채널에는 `connected` 및 `idle` 상태를 포함하는 상태가 있습니다.

gRPC가 채널 닫기를 처리하는 방법은 언어에 따라 다릅니다. 일부 언어는 채널 상태 쿼리도 허용합니다.



---

## 의견 / 진행

* 내가 했던 프로젝트도 API가 요청 받으면 응답주고 끝나는 Unary RPC만 사용했었다.  스트리밍 RPC나 양방향 스트리밍 RPC를 사용하진 않았다.

* 클라이언트에서 서비스 구분을 위한 메타데이터를 만들어, 서버의 인터셉터에서 요청 속 메타데이터를 꺼내서 서비스를 판단한 적이 있던 것도 생각이 난다.

  